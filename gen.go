package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"reflect"
	"strings"
)

func GenerateSimpleType(in any, extra string) error {
	t := reflect.TypeOf(in)
	l := strings.ToLower(string(t.Name()[0]))
	v, ok := t.FieldByName("v")
	if !ok {
		return fmt.Errorf("no v field in type %s", t.Name())
	}

	// Initialize the file
	f := bytes.NewBuffer(nil)
	fmt.Fprintf(f, "// This file is generated by screeps2go. DO NOT EDIT!\n")
	fmt.Fprintf(f, "package runtime\n")
	fmt.Fprintf(f, "import \"syscall/js\"\n")

	// Define the Type
	fmt.Fprintf(f, "type %s struct {\n", t.Name())
	for i := 0; i < t.NumField(); i++ {
		ff := t.Field(i)
		if !ff.IsExported() {
			continue
		}

		fmt.Fprintf(f, "%s %s `json:\"%s\"`\n", ff.Name, ff.Type.Name(), ff.Tag.Get("json"))
	}
	fmt.Fprintf(f, "}\n")

	// Create Value Generator
	fmt.Fprintf(f, "func (%s %s) Value() js.Value {\n", l, t.Name())
	fmt.Fprintf(f, "return js.Global()")
	jst := v.Tag.Get("js")
	jsk := v.Tag.Get("key")
	for _, p := range strings.Split(jst, ".") {
		if p == "%s" {
			fmt.Fprintf(f, ".Get(%s.%s)", l, jsk)
		} else {
			fmt.Fprintf(f, `.Get("%s")`, p)
		}
	}
	fmt.Fprintf(f, "\n}\n\n")

	// Create methods
	for i := 0; i < v.Type.NumMethod(); i++ {
		m := v.Type.Method(i)
		rt := m.Type.Out(0)

		fmt.Fprintf(f, "func (%s %s) %s(", l, t.Name(), m.Name)
		for j := 0; j < m.Type.NumIn(); j++ {
			arg := m.Type.In(j)
			n := arg.Name()
			if n == "Value" {
				n = "js.Value"
			}
			if arg.Kind() == reflect.Slice {
				n = "[]" + arg.Elem().Name()
			}
			fmt.Fprintf(f, "p%d %s", j, n)
			if j < m.Type.NumIn()-1 {
				fmt.Fprintf(f, ", ")
			}

		}

		rtn := rt.Name()
		if rt.Kind() == reflect.Slice {
			rten := rt.Elem().Name()
			if rten == "Value" {
				rten = "js.Value"
			}
			rtn = "[]" + rten
		}
		if rtn == "Value" {
			rtn = "js.Value"
		}
		fmt.Fprintf(f, ") %s {\n", rtn)

		inv := bytes.NewBuffer(nil)
		fmt.Fprintf(inv, "%s.Value().Call(\"%s\"", l, lcFirst(m.Name))
		for j := 0; j < m.Type.NumIn(); j++ {
			arg := m.Type.In(j)
			if arg.Kind() == reflect.Slice {
				fmt.Fprintf(inv, ", toInterfaceSlice(p%d)", j)
			} else {
				fmt.Fprintf(inv, ", p%d", j)
			}
		}
		fmt.Fprintf(inv, ")")

		switch rt.Name() {
		case "Error":
			fmt.Fprintf(f, "return Error(%s.Int())\n", inv.String())
		case "bool":
			fmt.Fprintf(f, "return %s.Bool()\n", inv.String())
		case "int":
			fmt.Fprintf(f, "return %s.Int()\n", inv.String())
		case "Value":
			fmt.Fprintf(f, "return %s\n", inv.String())
		}
		fmt.Fprintf(f, "}\n\n")
	}

	fmt.Fprint(f, extra)

	return FormatAndSave(f.Bytes(), t.Name())
}

func FormatAndSave(in []byte, name string) error {
	out, err := format.Source(in)
	if err != nil {
		// return err
		out = in
	}

	f, err := os.Create(fmt.Sprintf("runtime/%s.gen.go", strings.ToLower(name)))
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = f.Write(out)

	return err
}

func lcFirst(s string) string {
	return strings.ToLower(string(s[0])) + s[1:]
}
